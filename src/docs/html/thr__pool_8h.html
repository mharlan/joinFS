<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>joinFS: include/thr_pool.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>include/thr_pool.h File Reference</h1>  </div>
</div>
<div class="contents">
<code>#include &quot;<a class="el" href="sqlitedb_8h_source.html">sqlitedb.h</a>&quot;</code><br/>
<code>#include &lt;pthread.h&gt;</code><br/>

<p><a href="thr__pool_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef unsigned int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="thr__pool_8h.html#a12a1e9b3ce141648783a82445d02b58d">uint_t</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structthr__pool.html">thr_pool</a>&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="thr__pool_8h.html#a20e9093369f7f9ff7511da068aadca83">thr_pool_t</a></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structthr__pool.html">thr_pool_t</a> *&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="thr__pool_8h.html#a9794386cdbf43ccd797caa0efe03efc6">jfs_pool_create</a> (<a class="el" href="thr__pool_8h.html#a12a1e9b3ce141648783a82445d02b58d">uint_t</a> min_threads, <a class="el" href="thr__pool_8h.html#a12a1e9b3ce141648783a82445d02b58d">uint_t</a> max_threads, <a class="el" href="thr__pool_8h.html#a12a1e9b3ce141648783a82445d02b58d">uint_t</a> linger, pthread_attr_t *attr, int sqlite_attr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="thr__pool_8h.html#a50a33a87c802a7a80cfdc41cfc86f30c">jfs_pool_queue</a> (<a class="el" href="structthr__pool.html">thr_pool_t</a> *pool, struct <a class="el" href="structjfs__db__op.html">jfs_db_op</a> *db_op)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="thr__pool_8h.html#a4fbd5ceca90368ae3fa422648015c55f">jfs_pool_wait</a> (<a class="el" href="structthr__pool.html">thr_pool_t</a> *pool)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="thr__pool_8h.html#a9ba84127c49b25aaa2464ed62bd7e2f2">jfs_pool_destroy</a> (<a class="el" href="structthr__pool.html">thr_pool_t</a> *pool)</td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a20e9093369f7f9ff7511da068aadca83"></a><!-- doxytag: member="thr_pool.h::thr_pool_t" ref="a20e9093369f7f9ff7511da068aadca83" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structthr__pool.html">thr_pool</a> <a class="el" href="structthr__pool.html">thr_pool_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>The thr_pool_t type is opaque to the client. It is created by thr_pool_create() and must be passed unmodified to the remainder of the interfaces. </p>

</div>
</div>
<a class="anchor" id="a12a1e9b3ce141648783a82445d02b58d"></a><!-- doxytag: member="thr_pool.h::uint_t" ref="a12a1e9b3ce141648783a82445d02b58d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="thr__pool_8h.html#a12a1e9b3ce141648783a82445d02b58d">uint_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a9794386cdbf43ccd797caa0efe03efc6"></a><!-- doxytag: member="thr_pool.h::jfs_pool_create" ref="a9794386cdbf43ccd797caa0efe03efc6" args="(uint_t min_threads, uint_t max_threads, uint_t linger, pthread_attr_t *attr, int sqlite_attr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structthr__pool.html">thr_pool_t</a>* jfs_pool_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="thr__pool_8h.html#a12a1e9b3ce141648783a82445d02b58d">uint_t</a>&nbsp;</td>
          <td class="paramname"> <em>min_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thr__pool_8h.html#a12a1e9b3ce141648783a82445d02b58d">uint_t</a>&nbsp;</td>
          <td class="paramname"> <em>max_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="thr__pool_8h.html#a12a1e9b3ce141648783a82445d02b58d">uint_t</a>&nbsp;</td>
          <td class="paramname"> <em>linger</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pthread_attr_t *&nbsp;</td>
          <td class="paramname"> <em>attr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sqlite_attr</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Create a thread pool. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>min_threads</em>&nbsp;</td><td>The minimum number of threads kept in the pool, always available to perform work requests. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>max_threads</em>&nbsp;</td><td>The maximum number of threads that can be in the pool, performing work requests. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>linger</em>&nbsp;</td><td>The number of seconds excess idle worker threads (greater than min_threads) linger before exiting. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>attr</em>&nbsp;</td><td>Attributes of all worker threads (can be NULL). Can be destroyed after calling thr_pool_create(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>On error, thr_pool_create() returns NULL with errno set to the error code. </dd></dl>

<p><div class="fragment"><pre class="fragment">{
        <a class="code" href="structthr__pool.html">thr_pool_t</a>      *pool;

        (void) sigfillset(&amp;fillset);

        <span class="keywordflow">if</span>(min_threads &gt; max_threads || max_threads &lt; 1) {
      errno = EINVAL;
      <span class="keywordflow">return</span> NULL;
        }

        <span class="keywordflow">if</span>((pool = malloc(<span class="keyword">sizeof</span> (*pool))) == NULL) {
      errno = ENOMEM;
      <span class="keywordflow">return</span> NULL;
        }
    
        (void) pthread_mutex_init(&amp;pool-&gt;<a class="code" href="structthr__pool.html#ac79efd45606cb0611634b02e85fbc334">pool_mutex</a>, NULL);
        (void) pthread_cond_init(&amp;pool-&gt;<a class="code" href="structthr__pool.html#aedcb82844d345ef36cff542809203824">pool_busycv</a>, NULL);
        (void) pthread_cond_init(&amp;pool-&gt;<a class="code" href="structthr__pool.html#ad6d898706dd4c525dc6227e5f89f7ddf">pool_workcv</a>, NULL);
        (void) pthread_cond_init(&amp;pool-&gt;<a class="code" href="structthr__pool.html#a49cb54e317337da95c19ead99fd0289f">pool_waitcv</a>, NULL);
        pool-&gt;<a class="code" href="structthr__pool.html#a22cb592fd33f720c56b20a726deb5d2a">pool_active</a> = NULL;
        pool-&gt;<a class="code" href="structthr__pool.html#a4080e65fa1cd1011a9037223de630b31">pool_head</a> = NULL;
        pool-&gt;<a class="code" href="structthr__pool.html#a736e49f5e6628b0288595c6dc73a3202">pool_tail</a> = NULL;
        pool-&gt;<a class="code" href="structthr__pool.html#af8063de86663bedc6827513d88e8b848">pool_flags</a> = 0;
        pool-&gt;<a class="code" href="structthr__pool.html#a9d3ae71becdd8ad534d012603dc07645">pool_linger</a> = linger;
        pool-&gt;<a class="code" href="structthr__pool.html#ab6687bfd1308009028b86f337cf21573">pool_minimum</a> = min_threads;
        pool-&gt;<a class="code" href="structthr__pool.html#a9161c1f5dd18fe7d6e482363c65614ce">pool_maximum</a> = max_threads;
        pool-&gt;<a class="code" href="structthr__pool.html#a6304d8a2606cef0f561765808aa0b68d">pool_nthreads</a> = 0;
        pool-&gt;<a class="code" href="structthr__pool.html#a3b04e8be2ae1ef51809a8bda0c838c5c">pool_idle</a> = 0;
        pool-&gt;<a class="code" href="structthr__pool.html#a07889f76b9822774b2a2a50c91701d71">sqlite_attr</a> = sqlite_attr;

        <span class="comment">/*</span>
<span class="comment">         * We cannot just copy the attribute pointer.</span>
<span class="comment">         * We need to initialize a new pthread_attr_t structure using</span>
<span class="comment">         * the values from the caller-supplied attribute structure.</span>
<span class="comment">         * If the attribute pointer is NULL, we need to initialize</span>
<span class="comment">         * the new pthread_attr_t structure with default values.</span>
<span class="comment">         */</span>
        clone_attributes(&amp;pool-&gt;<a class="code" href="structthr__pool.html#ad0681ae3f8bda7f85b669bf7940777ef">pool_attr</a>, attr);

        <span class="comment">/* insert into the global list of all thread pools */</span>
        (void) pthread_mutex_lock(&amp;thr_pool_lock);
        <span class="keywordflow">if</span>(thr_pools == NULL) {
      pool-&gt;<a class="code" href="structthr__pool.html#a05fe5ead5a8e193468e6110d8b9ddee8">pool_forw</a> = pool;
      pool-&gt;<a class="code" href="structthr__pool.html#aa5d3015bfd8e1a18ccb9bc5017d40135">pool_back</a> = pool;
      thr_pools = pool;
        } 
    <span class="keywordflow">else</span> {
      thr_pools-&gt;<a class="code" href="structthr__pool.html#aa5d3015bfd8e1a18ccb9bc5017d40135">pool_back</a>-&gt;<a class="code" href="structthr__pool.html#a05fe5ead5a8e193468e6110d8b9ddee8">pool_forw</a> = pool;
      pool-&gt;<a class="code" href="structthr__pool.html#a05fe5ead5a8e193468e6110d8b9ddee8">pool_forw</a> = thr_pools;
      pool-&gt;<a class="code" href="structthr__pool.html#aa5d3015bfd8e1a18ccb9bc5017d40135">pool_back</a> = thr_pools-&gt;<a class="code" href="structthr__pool.html#aa5d3015bfd8e1a18ccb9bc5017d40135">pool_back</a>;
      thr_pools-&gt;<a class="code" href="structthr__pool.html#aa5d3015bfd8e1a18ccb9bc5017d40135">pool_back</a> = pool;
        }
        (void) pthread_mutex_unlock(&amp;thr_pool_lock);
    
        <span class="keywordflow">return</span> pool;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a9ba84127c49b25aaa2464ed62bd7e2f2"></a><!-- doxytag: member="thr_pool.h::jfs_pool_destroy" ref="a9ba84127c49b25aaa2464ed62bd7e2f2" args="(thr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jfs_pool_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structthr__pool.html">thr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Cancel all queued jobs and destroy the pool. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The thread pool. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment">{
  <a class="code" href="structactive.html">active_t</a> *activep;
  <a class="code" href="structjob.html">job_t</a> *<a class="code" href="structjob.html">job</a>;
  
  (void) pthread_mutex_lock(&amp;pool-&gt;<a class="code" href="structthr__pool.html#ac79efd45606cb0611634b02e85fbc334">pool_mutex</a>);
  pthread_cleanup_push((<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span> *))pthread_mutex_unlock, 
                       (<span class="keywordtype">void</span> *)&amp;pool-&gt;<a class="code" href="structthr__pool.html#ac79efd45606cb0611634b02e85fbc334">pool_mutex</a>);
  
  <span class="comment">/* mark the pool as being destroyed; wakeup idle workers */</span>
  pool-&gt;<a class="code" href="structthr__pool.html#af8063de86663bedc6827513d88e8b848">pool_flags</a> |= POOL_DESTROY;
  (void) pthread_cond_broadcast(&amp;pool-&gt;<a class="code" href="structthr__pool.html#ad6d898706dd4c525dc6227e5f89f7ddf">pool_workcv</a>);
  
  <span class="comment">/* cancel all active workers */</span>
  <span class="keywordflow">for</span>(activep = pool-&gt;<a class="code" href="structthr__pool.html#a22cb592fd33f720c56b20a726deb5d2a">pool_active</a>;
      activep != NULL;
      activep = activep-&gt;<a class="code" href="structactive.html#a130ff71824c05181cb04db21bc9c6b8e">active_next</a>) {
    (void) pthread_cancel(activep-&gt;<a class="code" href="structactive.html#a4d86c9ab0bc7e9dc9d6429a8abd624dd">active_tid</a>);
  }
  
  <span class="comment">/* wait for all active workers to finish */</span>
  <span class="keywordflow">while</span>(pool-&gt;<a class="code" href="structthr__pool.html#a22cb592fd33f720c56b20a726deb5d2a">pool_active</a> != NULL) {
    pool-&gt;<a class="code" href="structthr__pool.html#af8063de86663bedc6827513d88e8b848">pool_flags</a> |= POOL_WAIT;
    (void) pthread_cond_wait(&amp;pool-&gt;<a class="code" href="structthr__pool.html#a49cb54e317337da95c19ead99fd0289f">pool_waitcv</a>, &amp;pool-&gt;<a class="code" href="structthr__pool.html#ac79efd45606cb0611634b02e85fbc334">pool_mutex</a>);
  }
  
  <span class="comment">/* the last worker to terminate will wake us up */</span>
  <span class="keywordflow">while</span>(pool-&gt;<a class="code" href="structthr__pool.html#a6304d8a2606cef0f561765808aa0b68d">pool_nthreads</a> != 0) {
    (void) pthread_cond_wait(&amp;pool-&gt;<a class="code" href="structthr__pool.html#aedcb82844d345ef36cff542809203824">pool_busycv</a>, &amp;pool-&gt;<a class="code" href="structthr__pool.html#ac79efd45606cb0611634b02e85fbc334">pool_mutex</a>);
  }
  pthread_cleanup_pop(1);       <span class="comment">/* pthread_mutex_unlock(&amp;pool-&gt;pool_mutex); */</span>
  
  <span class="comment">/*</span>
<span class="comment">   * Unlink the pool from the global list of all pools.</span>
<span class="comment">   */</span>
  (void) pthread_mutex_lock(&amp;thr_pool_lock);
  <span class="keywordflow">if</span>(thr_pools == pool) {
    thr_pools = pool-&gt;<a class="code" href="structthr__pool.html#a05fe5ead5a8e193468e6110d8b9ddee8">pool_forw</a>;
  }
  <span class="keywordflow">if</span>(thr_pools == pool) {
    thr_pools = NULL;
  }
  <span class="keywordflow">else</span> {
    pool-&gt;<a class="code" href="structthr__pool.html#aa5d3015bfd8e1a18ccb9bc5017d40135">pool_back</a>-&gt;<a class="code" href="structthr__pool.html#a05fe5ead5a8e193468e6110d8b9ddee8">pool_forw</a> = pool-&gt;<a class="code" href="structthr__pool.html#a05fe5ead5a8e193468e6110d8b9ddee8">pool_forw</a>;
    pool-&gt;<a class="code" href="structthr__pool.html#a05fe5ead5a8e193468e6110d8b9ddee8">pool_forw</a>-&gt;<a class="code" href="structthr__pool.html#aa5d3015bfd8e1a18ccb9bc5017d40135">pool_back</a> = pool-&gt;<a class="code" href="structthr__pool.html#aa5d3015bfd8e1a18ccb9bc5017d40135">pool_back</a>;
  }
  (void) pthread_mutex_unlock(&amp;thr_pool_lock);

  <span class="comment">/*</span>
<span class="comment">   * There should be no pending jobs, but just in case...</span>
<span class="comment">   */</span>
  <span class="keywordflow">for</span>(job = pool-&gt;<a class="code" href="structthr__pool.html#a4080e65fa1cd1011a9037223de630b31">pool_head</a>; job != NULL; job = pool-&gt;<a class="code" href="structthr__pool.html#a4080e65fa1cd1011a9037223de630b31">pool_head</a>) {
    pool-&gt;<a class="code" href="structthr__pool.html#a4080e65fa1cd1011a9037223de630b31">pool_head</a> = job-&gt;<a class="code" href="structjob.html#a2a08b449eeaf0232cdf63cdd11512455">job_next</a>;
    free(job);
  }
  (void) pthread_attr_destroy(&amp;pool-&gt;<a class="code" href="structthr__pool.html#ad0681ae3f8bda7f85b669bf7940777ef">pool_attr</a>);
  free(pool);
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a50a33a87c802a7a80cfdc41cfc86f30c"></a><!-- doxytag: member="thr_pool.h::jfs_pool_queue" ref="a50a33a87c802a7a80cfdc41cfc86f30c" args="(thr_pool_t *pool, struct jfs_db_op *db_op)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int jfs_pool_queue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structthr__pool.html">thr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structjfs__db__op.html">jfs_db_op</a> *&nbsp;</td>
          <td class="paramname"> <em>db_op</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Enqueue a work request to the thread pool job queue. If there are idle worker threads, awaken one to perform the job. Else if the maximum number of workers has not been reached, create a new worker thread to perform the job. Else just return after adding the job to the queue; an existing worker thread will perform the job when it finishes the job it is currently performing.</p>
<p>The job is performed as if a new detached thread were created for it: pthread_create(NULL, attr, void *(*func)(void *), void *arg); </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The thread pool. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>db_op</em>&nbsp;</td><td>The database operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>On error, thr_pool_queue() returns -1 with errno set to the error code. </dd></dl>

<p><div class="fragment"><pre class="fragment">{
        <a class="code" href="structjob.html">job_t</a> *<a class="code" href="structjob.html">job</a>;

        <span class="keywordflow">if</span>((job = malloc(<span class="keyword">sizeof</span> (*job))) == NULL) {
      errno = ENOMEM;
      <span class="keywordflow">return</span> (-1);
        }
        job-&gt;<a class="code" href="structjob.html#a2a08b449eeaf0232cdf63cdd11512455">job_next</a> = NULL;
        job-&gt;<a class="code" href="structjob.html#accf991ef7ec77ef1b3dff6a9d8e16b41">db_op</a> = db_op;
    
        (void) pthread_mutex_lock(&amp;pool-&gt;<a class="code" href="structthr__pool.html#ac79efd45606cb0611634b02e85fbc334">pool_mutex</a>);

        <span class="keywordflow">if</span>(pool-&gt;<a class="code" href="structthr__pool.html#a4080e65fa1cd1011a9037223de630b31">pool_head</a> == NULL) {
      pool-&gt;<a class="code" href="structthr__pool.html#a4080e65fa1cd1011a9037223de630b31">pool_head</a> = job;
    }
        <span class="keywordflow">else</span> {
      pool-&gt;<a class="code" href="structthr__pool.html#a736e49f5e6628b0288595c6dc73a3202">pool_tail</a>-&gt;<a class="code" href="structjob.html#a2a08b449eeaf0232cdf63cdd11512455">job_next</a> = job;
    }
        pool-&gt;<a class="code" href="structthr__pool.html#a736e49f5e6628b0288595c6dc73a3202">pool_tail</a> = job;
    
        <span class="keywordflow">if</span>(pool-&gt;<a class="code" href="structthr__pool.html#a3b04e8be2ae1ef51809a8bda0c838c5c">pool_idle</a> &gt; 0) {
      (void) pthread_cond_signal(&amp;pool-&gt;<a class="code" href="structthr__pool.html#ad6d898706dd4c525dc6227e5f89f7ddf">pool_workcv</a>);
    }
        <span class="keywordflow">else</span> <span class="keywordflow">if</span>(pool-&gt;<a class="code" href="structthr__pool.html#a6304d8a2606cef0f561765808aa0b68d">pool_nthreads</a> &lt; pool-&gt;<a class="code" href="structthr__pool.html#a9161c1f5dd18fe7d6e482363c65614ce">pool_maximum</a> &amp;&amp;
            create_worker(pool) == 0) {
      pool-&gt;<a class="code" href="structthr__pool.html#a6304d8a2606cef0f561765808aa0b68d">pool_nthreads</a>++;
    }
    
        (void) pthread_mutex_unlock(&amp;pool-&gt;<a class="code" href="structthr__pool.html#ac79efd45606cb0611634b02e85fbc334">pool_mutex</a>);
        <span class="keywordflow">return</span> 0;
}
</pre></div></p>

</div>
</div>
<a class="anchor" id="a4fbd5ceca90368ae3fa422648015c55f"></a><!-- doxytag: member="thr_pool.h::jfs_pool_wait" ref="a4fbd5ceca90368ae3fa422648015c55f" args="(thr_pool_t *pool)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void jfs_pool_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structthr__pool.html">thr_pool_t</a> *&nbsp;</td>
          <td class="paramname"> <em>pool</em></td>
          <td>&nbsp;)&nbsp;</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Wait for all queued jobs to complete. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pool</em>&nbsp;</td><td>The thread pool. </td></tr>
  </table>
  </dd>
</dl>

<p><div class="fragment"><pre class="fragment">{
  (void) pthread_mutex_lock(&amp;pool-&gt;<a class="code" href="structthr__pool.html#ac79efd45606cb0611634b02e85fbc334">pool_mutex</a>);
  pthread_cleanup_push((<span class="keywordtype">void</span> (*)(<span class="keywordtype">void</span> *))pthread_mutex_unlock, 
                       (<span class="keywordtype">void</span> *)&amp;pool-&gt;<a class="code" href="structthr__pool.html#ac79efd45606cb0611634b02e85fbc334">pool_mutex</a>);
  <span class="keywordflow">while</span>(pool-&gt;<a class="code" href="structthr__pool.html#a4080e65fa1cd1011a9037223de630b31">pool_head</a> != NULL || pool-&gt;<a class="code" href="structthr__pool.html#a22cb592fd33f720c56b20a726deb5d2a">pool_active</a> != NULL) {
    pool-&gt;<a class="code" href="structthr__pool.html#af8063de86663bedc6827513d88e8b848">pool_flags</a> |= POOL_WAIT;
    (void) pthread_cond_wait(&amp;pool-&gt;<a class="code" href="structthr__pool.html#a49cb54e317337da95c19ead99fd0289f">pool_waitcv</a>, &amp;pool-&gt;<a class="code" href="structthr__pool.html#ac79efd45606cb0611634b02e85fbc334">pool_mutex</a>);
  }
  pthread_cleanup_pop(1);       <span class="comment">/* pthread_mutex_unlock(&amp;pool-&gt;pool_mutex); */</span>
}
</pre></div></p>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&nbsp;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Wed Apr 27 2011 04:27:44 for joinFS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
